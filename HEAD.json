{"files":[{"file":"bitmap/bitmap.h","functions":["tw_bitmap_new","tw_bitmap_free","tw_bitmap_copy","tw_bitmap_clone","tw_bitmap_set","tw_bitmap_clear","tw_bitmap_count","tw_bitmap_density","tw_bitmap_zero","tw_bitmap_fill","tw_bitmap_find_first_zero","tw_bitmap_find_first_bit","tw_bitmap_not","tw_bitmap_union","tw_bitmap_intersection","tw_bitmap_xor"],"meta":{},"lines":294},{"file":"bitmap/bitmap_rle.h","functions":["tw_bitmap_rle_new","tw_bitmap_rle_free","tw_bitmap_rle_copy","tw_bitmap_rle_clone","tw_bitmap_rle_set","tw_bitmap_rle_set_word","tw_bitmap_rle_set_range","tw_bitmap_rle_count","tw_bitmap_rle_density","tw_bitmap_rle_zero","tw_bitmap_rle_fill","tw_bitmap_rle_find_first_zero","tw_bitmap_rle_find_first_bit","tw_bitmap_rle_not","tw_bitmap_rle_union","tw_bitmap_rle_intersection"],"meta":{},"lines":283},{"file":"bloomfilter/bloomfilter.h","functions":["tw_bloomfilter_new","tw_bloomfilter_free","tw_bloomfilter_copy","tw_bloomfilter_clone","tw_bloomfilter_count","tw_bloomfilter_density","tw_bloomfilter_zero","tw_bloomfilter_fill","tw_bloomfilter_not","tw_bloomfilter_union","tw_bloomfilter_intersection","tw_bloomfilter_xor"],"meta":{},"lines":226},{"file":"bloomfilter/bloomfilter_a2.h","functions":["tw_bloomfilter_a2_new","tw_bloomfilter_a2_free","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_clone","tw_bloomfilter_a2_count","tw_bloomfilter_a2_density","tw_bloomfilter_a2_zero","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_xor"],"meta":{},"lines":231},{"file":"hash/minhash.h","functions":["tw_minhash_new","tw_minhash_free","tw_minhash_copy","tw_minhash_clone","tw_minhash_estimate","tw_minhash_merge"],"meta":{},"lines":123},{"file":"hyperloglog/hyperloglog.h","functions":["tw_hyperloglog_new","tw_hyperloglog_free","tw_hyperloglog_copy","tw_hyperloglog_clone","tw_hyperloglog_count","tw_hyperloglog_merge"],"meta":{},"lines":133}],"functions":{"tw_bitmap_new":{"type":"function","file":"bitmap/bitmap.h","line":40,"lineto":40,"args":[{"name":"size","type":"uint64_t","comment":"number of bits the bitmap should hold, must be smaller or equal\n             than `TW_BITMAP_MAX_BITS`"}],"argline":"uint64_t size","sig":"uint64_t","return":{"type":"struct tw_bitmap *","comment":" `NULL` if allocation failed, otherwise a pointer to the newly\n         allocated `struct tw_bitmap`"},"group":"bitmap","description":"<p>Creates a <code>struct tw_bitmap</code> with the requested number of bits.</p>\n","comments":""},"tw_bitmap_free":{"type":"function","file":"bitmap/bitmap.h","line":49,"lineto":49,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":"to free"}],"argline":"struct tw_bitmap *bitmap","sig":"struct tw_bitmap *","return":{"type":"void","comment":null},"group":"bitmap","description":"<p>Free a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_copy":{"type":"function","file":"bitmap/bitmap.h","line":61,"lineto":62,"args":[{"name":"src","type":"const struct tw_bitmap *","comment":"non-null bitmap to copy from"},{"name":"dst","type":"struct tw_bitmap *","comment":"non-null bitmap to copy to"}],"argline":"const struct tw_bitmap *src, struct tw_bitmap *dst","sig":"const struct tw_bitmap *::struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":" `NULL` if copy failed, otherwise a pointer to dst"},"group":"bitmap","description":"<p>Copy a source bitmap into a specified bitmap.</p>\n","comments":""},"tw_bitmap_clone":{"type":"function","file":"bitmap/bitmap.h","line":75,"lineto":75,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":"non-null bitmap to clone"}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":" `NULL` if failed, otherwise a newly allocated bitmap initialized from\n         the requests bitmap. The caller is responsible to deallocate the\n         bitmap with tw_bitmap_free"},"group":"bitmap","description":"<p>Clone a bitmap into a new allocated bitmap.</p>\n","comments":""},"tw_bitmap_set":{"type":"function","file":"bitmap/bitmap.h","line":85,"lineto":85,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":"non-null bitmap to set the position"},{"name":"pos","type":"uint64_t","comment":"position of the bit to set, must be smaller than `bitmap.size'"}],"argline":"struct tw_bitmap *bitmap, uint64_t pos","sig":"struct tw_bitmap *::uint64_t","return":{"type":"void","comment":null},"group":"bitmap","description":"<p>Set position in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_clear":{"type":"function","file":"bitmap/bitmap.h","line":95,"lineto":95,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":"bitmap non-null bitmap to clear the position"},{"name":"pos","type":"uint64_t","comment":"position of the bit to clear, must be smaller than `bitmap.size'"}],"argline":"struct tw_bitmap *bitmap, uint64_t pos","sig":"struct tw_bitmap *::uint64_t","return":{"type":"void","comment":null},"group":"bitmap","description":"<p>Clear position in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_count":{"type":"function","file":"bitmap/bitmap.h","line":171,"lineto":171,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":"non-null bitmap to count the number of active bits"}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"uint64_t","comment":" `0` if pre-conditions are not met, otherwise the number of active\n         bits."},"group":"bitmap","description":"<p>Count the number of active bits in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_density":{"type":"function","file":"bitmap/bitmap.h","line":183,"lineto":183,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":"non-null bitmap to count the density"}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"float","comment":" `0.0` if pre-conditions are not met, otherwise the proportion of\n         active bits, i.e. `bitmap.count / bitmap.size`"},"group":"bitmap","description":"<p>Count the proportion of active bits in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_zero":{"type":"function","file":"bitmap/bitmap.h","line":195,"lineto":195,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":"non-null bitmap to clear"}],"argline":"struct tw_bitmap *bitmap","sig":"struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":" `NULL` if pre-conditions are not met, otherwise `bitmap' with zeroed\n         bits."},"group":"bitmap","description":"<p>Clear all bits in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_fill":{"type":"function","file":"bitmap/bitmap.h","line":207,"lineto":207,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":"non-null bitmap to fill"}],"argline":"struct tw_bitmap *bitmap","sig":"struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":" `NULL` if pre-conditions are not met, otherwise `bitmap' with filled\n         bits."},"group":"bitmap","description":"<p>Set all bits in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_find_first_zero":{"type":"function","file":"bitmap/bitmap.h","line":219,"lineto":219,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":"non-null bitmap to find first zero"}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"int64_t","comment":" `-1` if not found or pre-conditions not met, otherwise the position\n         of the first zero."},"group":"bitmap","description":"<p>Find the first zero in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_find_first_bit":{"type":"function","file":"bitmap/bitmap.h","line":231,"lineto":231,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":"non-null bitmap to find first bit"}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"int64_t","comment":" `-1` if not found or pre-conditions not met, otherwise the position\n         of the first bit."},"group":"bitmap","description":"<p>Find the first bit in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_not":{"type":"function","file":"bitmap/bitmap.h","line":242,"lineto":242,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":"non-null bitmap to negate"}],"argline":"struct tw_bitmap *bitmap","sig":"struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":" `NULL` if failed, otherwise a pointer to `bitmap`"},"group":"bitmap","description":"<p>Negate all bits and zeroes in a <code>struct tw_bitmap</code>.</p>\n","comments":""},"tw_bitmap_union":{"type":"function","file":"bitmap/bitmap.h","line":267,"lineto":268,"args":[{"name":"src","type":"const struct tw_bitmap *","comment":"non-null source bitmap to union"},{"name":"dst","type":"struct tw_bitmap *","comment":"non-null destination bitmap to union of same size as `src`"}],"argline":"const struct tw_bitmap *src, struct tw_bitmap *dst","sig":"const struct tw_bitmap *::struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":" `NULL` if pre-conditions are not met, otherwise pointer to `dst`"},"group":"bitmap","description":"<p>Compute the in-place union of <code>struct tw_bitmap</code>s.</p>\n","comments":""},"tw_bitmap_intersection":{"type":"function","file":"bitmap/bitmap.h","line":280,"lineto":281,"args":[{"name":"src","type":"const struct tw_bitmap *","comment":"non-null source bitmap to union"},{"name":"dst","type":"struct tw_bitmap *","comment":"non-null destination bitmap to intersect of same size as `src`"}],"argline":"const struct tw_bitmap *src, struct tw_bitmap *dst","sig":"const struct tw_bitmap *::struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":" `NULL` if pre-conditions are not met, otherwise pointer to `dst`"},"group":"bitmap","description":"<p>Compute the in-place intersection of <code>struct tw_bitmap</code>s.</p>\n","comments":""},"tw_bitmap_xor":{"type":"function","file":"bitmap/bitmap.h","line":293,"lineto":294,"args":[{"name":"src","type":"const struct tw_bitmap *","comment":"non-null source bitmap to union"},{"name":"dst","type":"struct tw_bitmap *","comment":"non-null destination bitmap to xor of same size as `src`"}],"argline":"const struct tw_bitmap *src, struct tw_bitmap *dst","sig":"const struct tw_bitmap *::struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":" `NULL` if pre-conditions are not met, otherwise pointer to `dst`"},"group":"bitmap","description":"<p>Compute the in-place xor of <code>struct tw_bitmap</code>s.</p>\n","comments":""},"tw_bitmap_rle_new":{"type":"function","file":"bitmap/bitmap_rle.h","line":45,"lineto":45,"args":[{"name":"nbits","type":"uint64_t","comment":null}],"argline":"uint64_t nbits","sig":"uint64_t","return":{"type":"struct tw_bitmap_rle *","comment":" `NULL` if allocation failed, otherwise a pointer to the newly\n         allocated `struct tw_bitmap_rle`"},"group":"bitmap_rle","description":"<p>Creates a <code>struct tw_bitmap_rle</code> with the requested number of bits.</p>\n","comments":""},"tw_bitmap_rle_free":{"type":"function","file":"bitmap/bitmap_rle.h","line":54,"lineto":54,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":"to free"}],"argline":"struct tw_bitmap_rle *bitmap","sig":"struct tw_bitmap_rle *","return":{"type":"void","comment":null},"group":"bitmap_rle","description":"<p>Free a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_copy":{"type":"function","file":"bitmap/bitmap_rle.h","line":66,"lineto":67,"args":[{"name":"src","type":"const struct tw_bitmap_rle *","comment":"non-null bitmap to copy from"},{"name":"dst","type":"struct tw_bitmap_rle *","comment":"non-null bitmap to copy to"}],"argline":"const struct tw_bitmap_rle *src, struct tw_bitmap_rle *dst","sig":"const struct tw_bitmap_rle *::struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":" `NULL` if copy failed, otherwise a pointer to dst"},"group":"bitmap_rle","description":"<p>Copy a source bitmap into a specified bitmap.</p>\n","comments":""},"tw_bitmap_rle_clone":{"type":"function","file":"bitmap/bitmap_rle.h","line":79,"lineto":79,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":"non-null bitmap to clone"}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":" `NULL` if failed, otherwise a newly allocated bitmap initialized\n         from the requests bitmap"},"group":"bitmap_rle","description":"<p>Clone a bitmap into a new allocated bitmap.</p>\n","comments":""},"tw_bitmap_rle_set":{"type":"function","file":"bitmap/bitmap_rle.h","line":90,"lineto":90,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":"non-null bitmap to set the position"},{"name":"pos","type":"uint64_t","comment":"position of the bit to set, must be smaller than `bitmap.size',\n            note that `pos` must be called in a monotone increasing fashion"}],"argline":"struct tw_bitmap_rle *bitmap, uint64_t pos","sig":"struct tw_bitmap_rle *::uint64_t","return":{"type":"void","comment":null},"group":"bitmap_rle","description":"<p>Set position in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_set_word":{"type":"function","file":"bitmap/bitmap_rle.h","line":103,"lineto":104,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":"non-null bitmap to set the range"},{"name":"word","type":"const struct tw_bitmap_rle_word *","comment":"range of bits in the form (start_pos, count) to set in the\n             bitmap, `word.pos' must be smaller than `bitmap.size', and\n             `word.pos' + `word.count' must be smaller than\n             `TW_BITMAP_MAX_BITS`"}],"argline":"struct tw_bitmap_rle *bitmap, const struct tw_bitmap_rle_word *word","sig":"struct tw_bitmap_rle *::const struct tw_bitmap_rle_word *","return":{"type":"void","comment":null},"group":"bitmap_rle","description":"<p>Set a contiguous range in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_set_range":{"type":"function","file":"bitmap/bitmap_rle.h","line":117,"lineto":118,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":"non-null bitmap to set the range"},{"name":"start","type":"uint64_t","comment":"starting position to start setting bits, must be smaller than\n              `bitmap.size'"},{"name":"end","type":"uint64_t","comment":"end position to stop setting bits, must be smaller than\n              `bitmap.size'"}],"argline":"struct tw_bitmap_rle *bitmap, uint64_t start, uint64_t end","sig":"struct tw_bitmap_rle *::uint64_t::uint64_t","return":{"type":"void","comment":null},"group":"bitmap_rle","description":"<p>Set a contiguous range in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_count":{"type":"function","file":"bitmap/bitmap_rle.h","line":167,"lineto":167,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":"non-null bitmap to count the number of active bits"}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"uint64_t","comment":" `0` if pre-conditions are not met, otherwise the number of active\n         bits."},"group":"bitmap_rle","description":"<p>Count the number of active bits in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_density":{"type":"function","file":"bitmap/bitmap_rle.h","line":179,"lineto":179,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":"non-null bitmap to count the density"}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"float","comment":" `0.0` if pre-conditions are not met, otherwise the proportion of\n         active bits, i.e. `bitmap.count / bitmap.size`"},"group":"bitmap_rle","description":"<p>Count the proportion of active bits in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_zero":{"type":"function","file":"bitmap/bitmap_rle.h","line":191,"lineto":191,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":"non-null bitmap to clear"}],"argline":"struct tw_bitmap_rle *bitmap","sig":"struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":" `NULL` if pre-conditions are not met, otherwise `bitmap' with zeroed\n         bits."},"group":"bitmap_rle","description":"<p>Clear all bits in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_fill":{"type":"function","file":"bitmap/bitmap_rle.h","line":203,"lineto":203,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":"non-null bitmap to fill"}],"argline":"struct tw_bitmap_rle *bitmap","sig":"struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":" `NULL` if pre-conditions are not met, otherwise `bitmap' with filled\n         bits."},"group":"bitmap_rle","description":"<p>Set all bits in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_find_first_zero":{"type":"function","file":"bitmap/bitmap_rle.h","line":215,"lineto":215,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":"non-null bitmap to find first zero"}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"int64_t","comment":" `-1` if not found or pre-conditions not met, otherwise the position\n         of the first zero."},"group":"bitmap_rle","description":"<p>Find the first zero in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_find_first_bit":{"type":"function","file":"bitmap/bitmap_rle.h","line":227,"lineto":227,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":"non-null bitmap to find first bit"}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"int64_t","comment":" `-1` if not found or pre-conditions not met, otherwise the position\n         of the first bit."},"group":"bitmap_rle","description":"<p>Find the first bit in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_not":{"type":"function","file":"bitmap/bitmap_rle.h","line":238,"lineto":239,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":"non-null bitmap to negate"},{"name":"dst","type":"struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *bitmap, struct tw_bitmap_rle *dst","sig":"const struct tw_bitmap_rle *::struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":" `NULL` if failed, otherwise a pointer to `bitmap`"},"group":"bitmap_rle","description":"<p>Negate all bits and zeroes in a <code>struct tw_bitmap_rle</code>.</p>\n","comments":""},"tw_bitmap_rle_union":{"type":"function","file":"bitmap/bitmap_rle.h","line":266,"lineto":268,"args":[{"name":"a","type":"const struct tw_bitmap_rle *","comment":"non-null first operand bitmap to union"},{"name":"b","type":"const struct tw_bitmap_rle *","comment":"non-null second operand bitmap to union of same size as `a`"},{"name":"dst","type":"struct tw_bitmap_rle *","comment":"non-null destination bitmap to union of same size as `a`"}],"argline":"const struct tw_bitmap_rle *a, const struct tw_bitmap_rle *b, struct tw_bitmap_rle *dst","sig":"const struct tw_bitmap_rle *::const struct tw_bitmap_rle *::struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":" `NULL` if pre-conditions are not met, otherwise pointer to `dst`"},"group":"bitmap_rle","description":"<p>Compute the intersection of <code>struct tw_bitmap_rle</code>s.</p>\n","comments":""},"tw_bitmap_rle_intersection":{"type":"function","file":"bitmap/bitmap_rle.h","line":281,"lineto":283,"args":[{"name":"a","type":"const struct tw_bitmap_rle *","comment":"non-null first operand bitmap to union"},{"name":"b","type":"const struct tw_bitmap_rle *","comment":"non-null second operand bitmap to union"},{"name":"dst","type":"struct tw_bitmap_rle *","comment":"non-null destination bitmap to union of same size as `a`"}],"argline":"const struct tw_bitmap_rle *a, const struct tw_bitmap_rle *b, struct tw_bitmap_rle *dst","sig":"const struct tw_bitmap_rle *::const struct tw_bitmap_rle *::struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":" `NULL` if pre-conditions are not met, otherwise pointer to `dst`"},"group":"bitmap_rle","description":"<p>Compute the union of <code>struct tw_bitmap_rle</code>s.</p>\n","comments":""},"tw_bloomfilter_new":{"type":"function","file":"bloomfilter/bloomfilter.h","line":39,"lineto":39,"args":[{"name":"size","type":"uint64_t","comment":null},{"name":"k","type":"uint16_t","comment":null}],"argline":"uint64_t size, uint16_t k","sig":"uint64_t::uint16_t","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_new() - allocates a bloomfilter</p>\n\n<p>: number of bits the bloomfilter should hold</p>\n\n<p>:    number of hash functions used</p>\n","comments":"<p><code>k&#39; must be greater than 0,</code>size&#39; must be within (0, TW_BITMAP_MAX_BITS].</p>\n\n<p>Return: NULL if allocation failed, otherwise a pointer to the newly         allocated <code>struct tw_bloomfilter</code>.</p>\n"},"tw_bloomfilter_free":{"type":"function","file":"bloomfilter/bloomfilter.h","line":45,"lineto":45,"args":[{"name":"bf","type":"struct tw_bloomfilter *","comment":null}],"argline":"struct tw_bloomfilter *bf","sig":"struct tw_bloomfilter *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bloomfilter_free() - free a bloomfilter</p>\n\n<p>:\n bloomfilter to free</p>\n","comments":""},"tw_bloomfilter_copy":{"type":"function","file":"bloomfilter/bloomfilter.h","line":56,"lineto":57,"args":[{"name":"src","type":"const struct tw_bloomfilter *","comment":null},{"name":"dst","type":"struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *src, struct tw_bloomfilter *dst","sig":"const struct tw_bloomfilter *::struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_copy() - copy src bloomfilter into dst</p>\n\n<p>: bloomfilter to copy from</p>\n","comments":""},"tw_bloomfilter_clone":{"type":"function","file":"bloomfilter/bloomfilter.h","line":69,"lineto":69,"args":[{"name":"bf","type":"const struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *bf","sig":"const struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_clone() - clone a bloomfilter into a newly allocated one</p>\n\n<p>:\n bloomfilter to clone</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise a newly allocated bloomfilter initialized from the requested bloomfilter. The caller is responsible to deallocate with tw_bloomfilter_free.</p>\n"},"tw_bloomfilter_count":{"type":"function","file":"bloomfilter/bloomfilter.h","line":125,"lineto":125,"args":[{"name":"bf","type":"const struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *bf","sig":"const struct tw_bloomfilter *","return":{"type":"uint64_t","comment":null},"group":null,"description":"<p>tw_bloomfilter_count() - count the number of active bits</p>\n\n<p>:\n bloomfilter to count</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: number of active bits</p>\n"},"tw_bloomfilter_density":{"type":"function","file":"bloomfilter/bloomfilter.h","line":135,"lineto":135,"args":[{"name":"bf","type":"const struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *bf","sig":"const struct tw_bloomfilter *","return":{"type":"float","comment":null},"group":null,"description":"<p>tw_bloomfilter_density() - count the percentage of active bits</p>\n\n<p>:\n bloomfilter to count the density</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the portion of active bits (count / size)</p>\n"},"tw_bloomfilter_zero":{"type":"function","file":"bloomfilter/bloomfilter.h","line":145,"lineto":145,"args":[{"name":"bf","type":"struct tw_bloomfilter *","comment":null}],"argline":"struct tw_bloomfilter *bf","sig":"struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_zero() - clear all bits in a bloomfilter</p>\n\n<p>:\n bloomfilter to empty</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the bloomfilter cleared</p>\n"},"tw_bloomfilter_fill":{"type":"function","file":"bloomfilter/bloomfilter.h","line":155,"lineto":155,"args":[{"name":"bf","type":"struct tw_bloomfilter *","comment":null}],"argline":"struct tw_bloomfilter *bf","sig":"struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_fill() - set all bits in a bloomfilter</p>\n\n<p>:\n bloomfilter to fill</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the bloomfilter filled</p>\n"},"tw_bloomfilter_not":{"type":"function","file":"bloomfilter/bloomfilter.h","line":165,"lineto":165,"args":[{"name":"bf","type":"struct tw_bloomfilter *","comment":null}],"argline":"struct tw_bloomfilter *bf","sig":"struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_not() - inverse all bits and zeroes in the bloomfilter</p>\n\n<p>:\n bloomfilter to inverse</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise the bloomfilter.</p>\n"},"tw_bloomfilter_union":{"type":"function","file":"bloomfilter/bloomfilter.h","line":194,"lineto":195,"args":[{"name":"src","type":"const struct tw_bloomfilter *","comment":null},{"name":"dst","type":"struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *src, struct tw_bloomfilter *dst","sig":"const struct tw_bloomfilter *::struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_union() - computer the union of bloomfilters</p>\n\n<p>: source bloomfilter to union</p>\n","comments":""},"tw_bloomfilter_intersection":{"type":"function","file":"bloomfilter/bloomfilter.h","line":209,"lineto":211,"args":[{"name":"src","type":"const struct tw_bloomfilter *","comment":null},{"name":"dst","type":"struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *src, struct tw_bloomfilter *dst","sig":"const struct tw_bloomfilter *::struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_intersection() - compute the intersection of bloomfilters</p>\n\n<p>: source bloomfilter to intersection</p>\n","comments":""},"tw_bloomfilter_xor":{"type":"function","file":"bloomfilter/bloomfilter.h","line":225,"lineto":226,"args":[{"name":"src","type":"const struct tw_bloomfilter *","comment":null},{"name":"dst","type":"struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *src, struct tw_bloomfilter *dst","sig":"const struct tw_bloomfilter *::struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_xor() - compute the symetric difference of bloomfilters</p>\n\n<p>: source bloomfilter to xor</p>\n","comments":""},"tw_bloomfilter_a2_new":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":41,"lineto":42,"args":[{"name":"size","type":"uint64_t","comment":null},{"name":"k","type":"uint16_t","comment":null},{"name":"dentisy","type":"float","comment":null}],"argline":"uint64_t size, uint16_t k, float dentisy","sig":"uint64_t::uint16_t::float","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_new() - allocates a bloomfilter</p>\n\n<p>:    number of bits the bloomfilter should hold</p>\n\n<p>:       number of hash functions used</p>\n\n<p>: threshold for rotation</p>\n","comments":"<p><code>size&#39; must be within (0, TW_BITMAP_MAX_BITS],</code>k&#39; must be within (0, UINT16_MAX] and `density&#39; within (0, 1].</p>\n\n<p>Return: NULL if allocation failed, otherwise a pointer to the newly         allocated <code>struct tw_bloomfilter_a2</code>.</p>\n"},"tw_bloomfilter_a2_free":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":48,"lineto":48,"args":[{"name":"bf","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"struct tw_bloomfilter_a2 *bf","sig":"struct tw_bloomfilter_a2 *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_free() - free a bloomfilter</p>\n\n<p>:\n bloomfilter to free</p>\n","comments":""},"tw_bloomfilter_a2_copy":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":61,"lineto":63,"args":[{"name":"src","type":"const struct tw_bloomfilter_a2 *","comment":null},{"name":"dst","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *src, struct tw_bloomfilter_a2 *dst","sig":"const struct tw_bloomfilter_a2 *::struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_copy() - copy src bloomfilter into dst</p>\n\n<p>: bloomfilter to copy from</p>\n","comments":""},"tw_bloomfilter_a2_clone":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":75,"lineto":76,"args":[{"name":"bf","type":"const struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *bf","sig":"const struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_clone() - clone a bloomfilter into a newly allocated one</p>\n\n<p>:\n bloomfilter to clone</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise a newly allocated bloomfilter initialized from the requested bloomfilter. The caller is responsible to deallocate with tw_bloomfilter_a2_free.</p>\n"},"tw_bloomfilter_a2_count":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":128,"lineto":128,"args":[{"name":"bf","type":"const struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *bf","sig":"const struct tw_bloomfilter_a2 *","return":{"type":"uint64_t","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_count() - count the number of active bits</p>\n\n<p>:\n bloomfilter to count</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: number of active bits in both bloomfilters</p>\n"},"tw_bloomfilter_a2_density":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":138,"lineto":138,"args":[{"name":"bf","type":"const struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *bf","sig":"const struct tw_bloomfilter_a2 *","return":{"type":"float","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_density() - count the percentage of active bits</p>\n\n<p>:\n bloomfilter to count the density</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the portion of active bits (count / size)</p>\n"},"tw_bloomfilter_a2_zero":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":148,"lineto":148,"args":[{"name":"bf","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"struct tw_bloomfilter_a2 *bf","sig":"struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_zero() - clear all bits in a bloomfilter</p>\n\n<p>:\n bloomfilter to empty</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the bloomfilter cleared</p>\n"},"tw_bloomfilter_a2_fill":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":158,"lineto":158,"args":[{"name":"bf","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"struct tw_bloomfilter_a2 *bf","sig":"struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_fill() - set all bits in a bloomfilter</p>\n\n<p>:\n bloomfilter to fill</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the bloomfilter filled</p>\n"},"tw_bloomfilter_a2_not":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":168,"lineto":168,"args":[{"name":"bf","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"struct tw_bloomfilter_a2 *bf","sig":"struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_not() - inverse all bits and zeroes in the bloomfilter</p>\n\n<p>:\n bloomfilter to inverse</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise the bloomfilter.</p>\n"},"tw_bloomfilter_a2_union":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":197,"lineto":199,"args":[{"name":"src","type":"const struct tw_bloomfilter_a2 *","comment":null},{"name":"dst","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *src, struct tw_bloomfilter_a2 *dst","sig":"const struct tw_bloomfilter_a2 *::struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_union() - computer the union of bloomfilters</p>\n\n<p>: source bloomfilter to union</p>\n","comments":""},"tw_bloomfilter_a2_intersection":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":213,"lineto":215,"args":[{"name":"src","type":"const struct tw_bloomfilter_a2 *","comment":null},{"name":"dst","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *src, struct tw_bloomfilter_a2 *dst","sig":"const struct tw_bloomfilter_a2 *::struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_intersection() - compute the intersection of bloomfilters</p>\n\n<p>: source bloomfilter to intersection</p>\n","comments":""},"tw_bloomfilter_a2_xor":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":229,"lineto":231,"args":[{"name":"src","type":"const struct tw_bloomfilter_a2 *","comment":null},{"name":"dst","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *src, struct tw_bloomfilter_a2 *dst","sig":"const struct tw_bloomfilter_a2 *::struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_xor() - compute the symetric difference of bloomfilters</p>\n\n<p>: source bloomfilter to xor</p>\n","comments":""},"tw_minhash_new":{"type":"function","file":"hash/minhash.h","line":34,"lineto":34,"args":[{"name":"n_registers","type":"uint32_t","comment":"stricly positive number of 32bit registers the structure\n                    holds"}],"argline":"uint32_t n_registers","sig":"uint32_t","return":{"type":"struct tw_minhash *","comment":" `NULL` if allocation failed, otherwise a pointer to the newly\n         allocated `struct tw_minhash`."},"group":"minhash","description":"<p>Allocate a <code>struct tw_minhash</code>.</p>\n","comments":"<p>The allocation will be rounded up to the closest multiple of a cacheline.</p>\n"},"tw_minhash_free":{"type":"function","file":"hash/minhash.h","line":43,"lineto":43,"args":[{"name":"hash","type":"struct tw_minhash *","comment":"to free"}],"argline":"struct tw_minhash *hash","sig":"struct tw_minhash *","return":{"type":"void","comment":null},"group":"minhash","description":"<p>Free a <code>struct tw_minhash</code>.</p>\n","comments":""},"tw_minhash_copy":{"type":"function","file":"hash/minhash.h","line":56,"lineto":57,"args":[{"name":"src","type":"const struct tw_minhash *","comment":"non-null minhash to copy from"},{"name":"dst","type":"struct tw_minhash *","comment":"non-null minhash to copy to"}],"argline":"const struct tw_minhash *src, struct tw_minhash *dst","sig":"const struct tw_minhash *::struct tw_minhash *","return":{"type":"struct tw_minhash *","comment":" `NULL` if any hash is null or not of the same cardinality, otherwise\n         a pointer to dst"},"group":"minhash","description":"<p>Copy a source <code>struct tw_minhash</code> into a specified destination.</p>\n","comments":""},"tw_minhash_clone":{"type":"function","file":"hash/minhash.h","line":70,"lineto":70,"args":[{"name":"hash","type":"const struct tw_minhash *","comment":"non-null minhash to clone"}],"argline":"const struct tw_minhash *hash","sig":"const struct tw_minhash *","return":{"type":"struct tw_minhash *","comment":" `NULL` if failed, otherwise a newly allocated minhash initialized\n         from the requests minhash. The caller is responsible to deallocate\n         the minhash with tw_minhash_free"},"group":"minhash","description":"<p>Clone a <code>struct tw_minhash</code> into a newly allocated one.</p>\n","comments":""},"tw_minhash_estimate":{"type":"function","file":"hash/minhash.h","line":94,"lineto":95,"args":[{"name":"fst","type":"const struct tw_minhash *","comment":"non-null first minhash"},{"name":"snd","type":"const struct tw_minhash *","comment":"non-null second minhash"}],"argline":"const struct tw_minhash *fst, const struct tw_minhash *snd","sig":"const struct tw_minhash *::const struct tw_minhash *","return":{"type":"float","comment":" `0.0` if any hash is null or hashes are not of the same cardinality,\n         otherwise the estimated jaccard index between `fst` and `snd`"},"group":"minhash","description":"<p>Estimate the jaccard index between two <code>struct tw_minhash</code>s.</p>\n","comments":""},"tw_minhash_merge":{"type":"function","file":"hash/minhash.h","line":122,"lineto":123,"args":[{"name":"src","type":"const struct tw_minhash *","comment":"non-null minhash to merge from"},{"name":"dst","type":"struct tw_minhash *","comment":"non-null minhash to merge to"}],"argline":"const struct tw_minhash *src, struct tw_minhash *dst","sig":"const struct tw_minhash *::struct tw_minhash *","return":{"type":"struct tw_minhash *","comment":" `NULL` if any hash is null or hashes are not of the same cardinality,\n         otherwise pointer to dst with merged registers"},"group":"minhash","description":"<p>Merge a <code>struct tw_minhash</code> in a specified destination.</p>\n","comments":""},"tw_hyperloglog_new":{"type":"function","file":"hyperloglog/hyperloglog.h","line":44,"lineto":44,"args":[{"name":"precision","type":"uint8_t","comment":"power-of-2 exponent number of bucket hyperloglog should use,\n                  must be greater or equal than `TW_HLL_MIN_PRECISION and\n                  smaller or equal than `TW_HLL_MAX_PRECISION`"}],"argline":"uint8_t precision","sig":"uint8_t","return":{"type":"struct tw_hyperloglog *","comment":" `NULL` if allocation failed, otherwise a pointer to the newly\n         allocated `struct tw_hyperloglog`."},"group":"hyperloglog","description":"<p>Allocate a <code>struct tw_hyperloglog</code>.</p>\n","comments":""},"tw_hyperloglog_free":{"type":"function","file":"hyperloglog/hyperloglog.h","line":53,"lineto":53,"args":[{"name":"hll","type":"struct tw_hyperloglog *","comment":"to free"}],"argline":"struct tw_hyperloglog *hll","sig":"struct tw_hyperloglog *","return":{"type":"void","comment":null},"group":"hyperloglog","description":"<p>Free a <code>struct tw_hyperloglog</code>.</p>\n","comments":""},"tw_hyperloglog_copy":{"type":"function","file":"hyperloglog/hyperloglog.h","line":65,"lineto":66,"args":[{"name":"src","type":"const struct tw_hyperloglog *","comment":"non-null hyperloglog to copy from"},{"name":"dst","type":"struct tw_hyperloglog *","comment":"non-null hyperloglog of the same precision has src to copy to"}],"argline":"const struct tw_hyperloglog *src, struct tw_hyperloglog *dst","sig":"const struct tw_hyperloglog *::struct tw_hyperloglog *","return":{"type":"struct tw_hyperloglog *","comment":" `NULL` if copy failed, otherwise a pointer to dst"},"group":"hyperloglog","description":"<p>Copy a source <code>struct tw_hyperloglog</code> into a specified destination.</p>\n","comments":""},"tw_hyperloglog_clone":{"type":"function","file":"hyperloglog/hyperloglog.h","line":79,"lineto":79,"args":[{"name":"hll","type":"const struct tw_hyperloglog *","comment":"non-null hyperloglog to clone"}],"argline":"const struct tw_hyperloglog *hll","sig":"const struct tw_hyperloglog *","return":{"type":"struct tw_hyperloglog *","comment":" `NULL` if failed, otherwise a newly allocated hyperloglog initialized\n         from the requested hyperloglog. The caller is responsible to\n         deallocate with tw_hyperloglog_free"},"group":"hyperloglog","description":"<p>Clone a <code>struct tw_hyperloglog</code> into a newly allocated one.</p>\n","comments":""},"tw_hyperloglog_count":{"type":"function","file":"hyperloglog/hyperloglog.h","line":103,"lineto":103,"args":[{"name":"hll","type":"const struct tw_hyperloglog *","comment":"non-null hyperloglog to estimate"}],"argline":"const struct tw_hyperloglog *hll","sig":"const struct tw_hyperloglog *","return":{"type":"double","comment":" `0.0` if hll is NULL, otherwise the estimated number of elements\n         in hll."},"group":"hyperloglog","description":"<p>Estimate the number of elements in a <code>struct tw_hyperloglog</code>.</p>\n","comments":""},"tw_hyperloglog_merge":{"type":"function","file":"hyperloglog/hyperloglog.h","line":132,"lineto":133,"args":[{"name":"src","type":"const struct tw_hyperloglog *","comment":"non-null hyperloglog to merge from"},{"name":"dst","type":"struct tw_hyperloglog *","comment":"non-null hyperloglog to merge to"}],"argline":"const struct tw_hyperloglog *src, struct tw_hyperloglog *dst","sig":"const struct tw_hyperloglog *::struct tw_hyperloglog *","return":{"type":"struct tw_hyperloglog *","comment":" `NULL` if any is null or not of the same precision, otherwise a\n         pointer to merged `dst'"},"group":"hyperloglog","description":"<p>Merge a <code>struct tw_hyperloglog</code> in a specified destination.</p>\n","comments":"<p>The merge operation is an elemwise max applied to the buckets.</p>\n"}},"callbacks":{},"globals":{},"types":[["tw_bitmap",{"decl":["uint64_t size","uint64_t count","uint64_t * data"],"type":"struct","value":"tw_bitmap","file":"bitmap/bitmap.h","line":20,"lineto":27,"block":"uint64_t size\nuint64_t count\nuint64_t * data","tdef":null,"description":" dense bitmap data structure","comments":"<p>This is the most basic implementation of a bitmap. It does not support resizing and concurrent operations (unless constrained to reads only).</p>\n\n<p>There&#39;s a small overhead when setting/clearing bit to maintain the number of active bits. This comes with a O(1) tw_bitmap_count and derived operations.</p>\n","fields":[{"type":"uint64_t","name":"size","comments":" storage capacity in bits "},{"type":"uint64_t","name":"count","comments":" number of active bits "},{"type":"uint64_t *","name":"data","comments":" pointer to stored bits "}],"used":{"returns":["tw_bitmap_clone","tw_bitmap_copy","tw_bitmap_fill","tw_bitmap_intersection","tw_bitmap_new","tw_bitmap_not","tw_bitmap_rle_clone","tw_bitmap_rle_copy","tw_bitmap_rle_fill","tw_bitmap_rle_intersection","tw_bitmap_rle_new","tw_bitmap_rle_not","tw_bitmap_rle_union","tw_bitmap_rle_zero","tw_bitmap_union","tw_bitmap_xor","tw_bitmap_zero"],"needs":["tw_bitmap_clear","tw_bitmap_clone","tw_bitmap_copy","tw_bitmap_count","tw_bitmap_density","tw_bitmap_fill","tw_bitmap_find_first_bit","tw_bitmap_find_first_zero","tw_bitmap_free","tw_bitmap_intersection","tw_bitmap_not","tw_bitmap_rle_clone","tw_bitmap_rle_copy","tw_bitmap_rle_count","tw_bitmap_rle_density","tw_bitmap_rle_fill","tw_bitmap_rle_find_first_bit","tw_bitmap_rle_find_first_zero","tw_bitmap_rle_free","tw_bitmap_rle_intersection","tw_bitmap_rle_not","tw_bitmap_rle_set","tw_bitmap_rle_set_range","tw_bitmap_rle_set_word","tw_bitmap_rle_union","tw_bitmap_rle_zero","tw_bitmap_set","tw_bitmap_union","tw_bitmap_xor","tw_bitmap_zero"]}}],["tw_bitmap_rle",{"decl":["uint64_t size","uint64_t count","uint64_t last_pos","uint64_t last_word_idx","uint64_t alloc_word","struct tw_bitmap_rle_word * data"],"type":"struct","value":"tw_bitmap_rle","file":"bitmap/bitmap_rle.h","line":19,"lineto":32,"block":"uint64_t size\nuint64_t count\nuint64_t last_pos\nuint64_t last_word_idx\nuint64_t alloc_word\nstruct tw_bitmap_rle_word * data","tdef":null,"description":" run-length encoding (RLE) bitmap data structure","comments":"<p>RLE bitmaps are compressed bitmaps. Depending on the density of actives bits, it can compress considerably. This implementation is semi mutable as you can only add increasing positions.</p>\n","fields":[{"type":"uint64_t","name":"size","comments":" storage capacity in bits "},{"type":"uint64_t","name":"count","comments":" number of active bits "},{"type":"uint64_t","name":"last_pos","comments":" position of the last set bit "},{"type":"uint64_t","name":"last_word_idx","comments":" index of the last used `struct tw_bitmap_rle_word` in "},{"type":"uint64_t","name":"alloc_word","comments":" number of allocated `struct tw_bitmap_rle_word` in "},{"type":"struct tw_bitmap_rle_word *","name":"data","comments":" buffer holding the bits "}],"used":{"returns":["tw_bitmap_rle_clone","tw_bitmap_rle_copy","tw_bitmap_rle_fill","tw_bitmap_rle_intersection","tw_bitmap_rle_new","tw_bitmap_rle_not","tw_bitmap_rle_union","tw_bitmap_rle_zero"],"needs":["tw_bitmap_rle_clone","tw_bitmap_rle_copy","tw_bitmap_rle_count","tw_bitmap_rle_density","tw_bitmap_rle_fill","tw_bitmap_rle_find_first_bit","tw_bitmap_rle_find_first_zero","tw_bitmap_rle_free","tw_bitmap_rle_intersection","tw_bitmap_rle_not","tw_bitmap_rle_set","tw_bitmap_rle_set_range","tw_bitmap_rle_set_word","tw_bitmap_rle_union","tw_bitmap_rle_zero"]}}],["tw_bloomfilter",{"decl":["uint16_t k","struct tw_bitmap * bitmap"],"type":"struct","value":"tw_bloomfilter","file":"bloomfilter/bloomfilter.h","line":24,"lineto":27,"block":"uint16_t k\nstruct tw_bitmap * bitmap","tdef":null,"description":" struct tw_bloomfilter - bloomfilter\n \n\n:      number of hash functions\n \n\n: bitmap holding the bits","comments":"<p>This bloomfilter is static and does not support automatic resizing. The underlaying storage is struct tw_bitmap.</p>\n","fields":[{"type":"uint16_t","name":"k","comments":""},{"type":"struct tw_bitmap *","name":"bitmap","comments":""}],"used":{"returns":["tw_bloomfilter_a2_clone","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_new","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_xor","tw_bloomfilter_a2_zero","tw_bloomfilter_clone","tw_bloomfilter_copy","tw_bloomfilter_fill","tw_bloomfilter_intersection","tw_bloomfilter_new","tw_bloomfilter_not","tw_bloomfilter_union","tw_bloomfilter_xor","tw_bloomfilter_zero"],"needs":["tw_bloomfilter_a2_clone","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_count","tw_bloomfilter_a2_density","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_free","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_xor","tw_bloomfilter_a2_zero","tw_bloomfilter_clone","tw_bloomfilter_copy","tw_bloomfilter_count","tw_bloomfilter_density","tw_bloomfilter_fill","tw_bloomfilter_free","tw_bloomfilter_intersection","tw_bloomfilter_not","tw_bloomfilter_union","tw_bloomfilter_xor","tw_bloomfilter_zero"]}}],["tw_bloomfilter_a2",{"decl":["float density","struct tw_bloomfilter * active","struct tw_bloomfilter * passive"],"type":"struct","value":"tw_bloomfilter_a2","file":"bloomfilter/bloomfilter_a2.h","line":22,"lineto":27,"block":"float density\nstruct tw_bloomfilter * active\nstruct tw_bloomfilter * passive","tdef":null,"description":" struct tw_bloomfilter_a2 - aging bloom filter with active buffers\n \n\n: density threshold to trigger rotation\n \n\n:  pointer to active bloomfilter\n \n\n: pointer to passive bloomfilter","comments":"<p>The paper &quot;Aging bloom filter with two active buffers for dynamic sets&quot; describe a method where 2 bloom filters are used to implement a FIFO.</p>\n\n<p>Elements are added to <code>active</code> until <code>density</code> (on active). Once this happen, <code>passive</code> is cleared and both filters are swapped.</p>\n","fields":[{"type":"float","name":"density","comments":""},{"type":"struct tw_bloomfilter *","name":"active","comments":""},{"type":"struct tw_bloomfilter *","name":"passive","comments":""}],"used":{"returns":["tw_bloomfilter_a2_clone","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_new","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_xor","tw_bloomfilter_a2_zero"],"needs":["tw_bloomfilter_a2_clone","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_count","tw_bloomfilter_a2_density","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_free","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_xor","tw_bloomfilter_a2_zero"]}}],["tw_hyperloglog",{"decl":["uint8_t precision","uint8_t * registers"],"type":"struct","value":"tw_hyperloglog","file":"hyperloglog/hyperloglog.h","line":25,"lineto":30,"block":"uint8_t precision\nuint8_t * registers","tdef":null,"description":" hyperloglog data structure","comments":"<p>This implementation does not use the 6-bit packing and/or mix dense/sparse representation proposed in the [1].</p>\n\n<p>[1] Heule, Stefan, Marc Nunkesser, and Alexander Hall. &quot;HyperLogLog in practice: Algorithmic engineering of a state of the art cardinality estimation algorithm.&quot; Proceedings of the 16th International Conference on Extending Database Technology. ACM, 2013.</p>\n","fields":[{"type":"uint8_t","name":"precision","comments":" the number of registers will be defined as 2^precision "},{"type":"uint8_t *","name":"registers","comments":" allocated array containing the 8bit registers "}],"used":{"returns":["tw_hyperloglog_clone","tw_hyperloglog_copy","tw_hyperloglog_merge","tw_hyperloglog_new"],"needs":["tw_hyperloglog_clone","tw_hyperloglog_copy","tw_hyperloglog_count","tw_hyperloglog_free","tw_hyperloglog_merge"]}}],["tw_minhash",{"decl":["uint32_t n_registers","uint32_t * registers"],"type":"struct","value":"tw_minhash","file":"hash/minhash.h","line":13,"lineto":18,"block":"uint32_t n_registers\nuint32_t * registers","tdef":null,"description":" minhash data structure","comments":"<p>This implementation forces use of 32bits buckets. It also uses max instead of min, since it&#39;s homomorphic.</p>\n","fields":[{"type":"uint32_t","name":"n_registers","comments":" number of registers "},{"type":"uint32_t *","name":"registers","comments":" registers holding computed values "}],"used":{"returns":["tw_minhash_clone","tw_minhash_copy","tw_minhash_merge","tw_minhash_new"],"needs":["tw_minhash_clone","tw_minhash_copy","tw_minhash_estimate","tw_minhash_free","tw_minhash_merge"]}}]],"prefix":"include/twiddle","groups":[["bitmap",["tw_bitmap_new","tw_bitmap_free","tw_bitmap_copy","tw_bitmap_clone","tw_bitmap_set","tw_bitmap_clear","tw_bitmap_count","tw_bitmap_density","tw_bitmap_zero","tw_bitmap_fill","tw_bitmap_find_first_zero","tw_bitmap_find_first_bit","tw_bitmap_not","tw_bitmap_union","tw_bitmap_intersection","tw_bitmap_xor"]],["bitmap_rle",["tw_bitmap_rle_new","tw_bitmap_rle_free","tw_bitmap_rle_copy","tw_bitmap_rle_clone","tw_bitmap_rle_set","tw_bitmap_rle_set_word","tw_bitmap_rle_set_range","tw_bitmap_rle_count","tw_bitmap_rle_density","tw_bitmap_rle_zero","tw_bitmap_rle_fill","tw_bitmap_rle_find_first_zero","tw_bitmap_rle_find_first_bit","tw_bitmap_rle_not","tw_bitmap_rle_union","tw_bitmap_rle_intersection"]],["hyperloglog",["tw_hyperloglog_new","tw_hyperloglog_free","tw_hyperloglog_copy","tw_hyperloglog_clone","tw_hyperloglog_count","tw_hyperloglog_merge"]],["minhash",["tw_minhash_new","tw_minhash_free","tw_minhash_copy","tw_minhash_clone","tw_minhash_estimate","tw_minhash_merge"]],["no_group",["tw_bloomfilter_new","tw_bloomfilter_free","tw_bloomfilter_copy","tw_bloomfilter_clone","tw_bloomfilter_count","tw_bloomfilter_density","tw_bloomfilter_zero","tw_bloomfilter_fill","tw_bloomfilter_not","tw_bloomfilter_union","tw_bloomfilter_intersection","tw_bloomfilter_xor","tw_bloomfilter_a2_new","tw_bloomfilter_a2_free","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_clone","tw_bloomfilter_a2_count","tw_bloomfilter_a2_density","tw_bloomfilter_a2_zero","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_xor"]]],"examples":[["bf-uniq.c","ex/HEAD/bf-uniq.html"],["example-bitmap-rle.c","ex/HEAD/example-bitmap-rle.html"],["example-bitmap.c","ex/HEAD/example-bitmap.html"],["example-bloomfilter-a2.c","ex/HEAD/example-bloomfilter-a2.html"],["example-bloomfilter.c","ex/HEAD/example-bloomfilter.html"],["example-hyperloglog.c","ex/HEAD/example-hyperloglog.html"],["example-minhash.c","ex/HEAD/example-minhash.html"],["hll-wc.c","ex/HEAD/hll-wc.html"]]}