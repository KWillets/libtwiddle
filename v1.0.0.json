{"files":[{"file":"bitmap/bitmap.h","functions":["tw_bitmap_new","tw_bitmap_free","tw_bitmap_copy","tw_bitmap_clone","tw_bitmap_set","tw_bitmap_clear","tw_bitmap_count","tw_bitmap_density","tw_bitmap_zero","tw_bitmap_fill","tw_bitmap_find_first_zero","tw_bitmap_find_first_bit","tw_bitmap_not","tw_bitmap_union","tw_bitmap_intersection","tw_bitmap_xor"],"meta":{},"lines":268},{"file":"bitmap/bitmap_rle.h","functions":["tw_bitmap_rle_new","tw_bitmap_rle_free","tw_bitmap_rle_copy","tw_bitmap_rle_clone","tw_bitmap_rle_set","tw_bitmap_rle_set_word","tw_bitmap_rle_set_range","tw_bitmap_rle_count","tw_bitmap_rle_density","tw_bitmap_rle_zero","tw_bitmap_rle_fill","tw_bitmap_rle_find_first_zero","tw_bitmap_rle_find_first_bit","tw_bitmap_rle_not","tw_bitmap_rle_union","tw_bitmap_rle_intersection"],"meta":{},"lines":266},{"file":"bloomfilter/bloomfilter.h","functions":["tw_bloomfilter_new","tw_bloomfilter_free","tw_bloomfilter_copy","tw_bloomfilter_clone","tw_bloomfilter_count","tw_bloomfilter_density","tw_bloomfilter_zero","tw_bloomfilter_fill","tw_bloomfilter_not","tw_bloomfilter_union","tw_bloomfilter_intersection","tw_bloomfilter_xor"],"meta":{},"lines":226},{"file":"bloomfilter/bloomfilter_a2.h","functions":["tw_bloomfilter_a2_new","tw_bloomfilter_a2_free","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_clone","tw_bloomfilter_a2_count","tw_bloomfilter_a2_density","tw_bloomfilter_a2_zero","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_xor"],"meta":{},"lines":231},{"file":"hash/minhash.h","functions":["tw_minhash_new","tw_minhash_free","tw_minhash_copy","tw_minhash_clone","tw_minhash_estimate","tw_minhash_merge"],"meta":{},"lines":109},{"file":"hyperloglog/hyperloglog.h","functions":["tw_hyperloglog_new","tw_hyperloglog_free","tw_hyperloglog_copy","tw_hyperloglog_clone","tw_hyperloglog_count","tw_hyperloglog_merge"],"meta":{},"lines":118}],"functions":{"tw_bitmap_new":{"type":"function","file":"bitmap/bitmap.h","line":39,"lineto":39,"args":[{"name":"size","type":"uint64_t","comment":null}],"argline":"uint64_t size","sig":"uint64_t","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_new() - allocates a bitmap</p>\n\n<p>: number of bits the bitmap should hold</p>\n","comments":"<p>Bitmaps are static and do not grow in size. Bitmaps cannot contain more than TW_BITMAP_MAX_BITS.</p>\n\n<p>Return: NULL if allocation failed, otherwise a pointer to the newly         allocated <code>struct tw_bitmap</code>.</p>\n"},"tw_bitmap_free":{"type":"function","file":"bitmap/bitmap.h","line":45,"lineto":45,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":null}],"argline":"struct tw_bitmap *bitmap","sig":"struct tw_bitmap *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bitmap_free() - free a bitmap</p>\n\n<p>: bitmap to free</p>\n","comments":""},"tw_bitmap_copy":{"type":"function","file":"bitmap/bitmap.h","line":56,"lineto":57,"args":[{"name":"src","type":"const struct tw_bitmap *","comment":null},{"name":"dst","type":"struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *src, struct tw_bitmap *dst","sig":"const struct tw_bitmap *::struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_copy() - copy src bitmap into dst</p>\n\n<p>: bitmap to copy from</p>\n","comments":""},"tw_bitmap_clone":{"type":"function","file":"bitmap/bitmap.h","line":69,"lineto":69,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_clone() - clone a bitmap into a new allocated bitmap</p>\n\n<p>: bitmap to clone</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise a newly allocated bitmap initialized from the requests bitmap. The caller is responsible to deallocate the bitmap with tw_bitmap_free.</p>\n"},"tw_bitmap_set":{"type":"function","file":"bitmap/bitmap.h","line":78,"lineto":78,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":null},{"name":"pos","type":"uint64_t","comment":null}],"argline":"struct tw_bitmap *bitmap, uint64_t pos","sig":"struct tw_bitmap *::uint64_t","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bitmap_set() - set position in bitmap</p>\n\n<p>: bitmap affected</p>\n","comments":"<p><code>bitmap&#39; must be non-null and</code>pos&#39; must be smaller than `bitmap.size&#39;.</p>\n"},"tw_bitmap_clear":{"type":"function","file":"bitmap/bitmap.h","line":87,"lineto":87,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":null},{"name":"pos","type":"uint64_t","comment":null}],"argline":"struct tw_bitmap *bitmap, uint64_t pos","sig":"struct tw_bitmap *::uint64_t","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bitmap_clear() - clear position in bitmap</p>\n\n<p>: bitmap affected</p>\n","comments":"<p><code>bitmap&#39; must be non-null and</code>pos&#39; must be smaller than `bitmap.size&#39;.</p>\n"},"tw_bitmap_count":{"type":"function","file":"bitmap/bitmap.h","line":155,"lineto":155,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"uint64_t","comment":null},"group":null,"description":"<p>tw_bitmap_count() - count the number of active bits</p>\n\n<p>: bitmap to count</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: 0 if pre-conditions are not met, otherwise number of active bits.</p>\n"},"tw_bitmap_density":{"type":"function","file":"bitmap/bitmap.h","line":166,"lineto":166,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"float","comment":null},"group":null,"description":"<p>tw_bitmap_density() - count the percentage of active bits</p>\n\n<p>: bitmap to count the density</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: 0.0 if pre-conditions are not met, otherwise the portion of active bits (count / size)</p>\n"},"tw_bitmap_zero":{"type":"function","file":"bitmap/bitmap.h","line":177,"lineto":177,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":null}],"argline":"struct tw_bitmap *bitmap","sig":"struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_zero() - clear all bits in a bitmap</p>\n\n<p>: bitmap to empty</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: NULL if pre-conditions are not met, otherwise `bitmap&#39; with zeroed bits.</p>\n"},"tw_bitmap_fill":{"type":"function","file":"bitmap/bitmap.h","line":188,"lineto":188,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":null}],"argline":"struct tw_bitmap *bitmap","sig":"struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_fill() - set all bits in a bitmap</p>\n\n<p>: bitmap to fill</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: NULL if pre-conditions are not met, otherwise `bitmap&#39; with filled bits.</p>\n"},"tw_bitmap_find_first_zero":{"type":"function","file":"bitmap/bitmap.h","line":199,"lineto":199,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"int64_t","comment":null},"group":null,"description":"<p>tw_bitmap_find_first_zero() - find the first zero</p>\n\n<p>: bitmap to find first zero</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: -1 if not found or pre-conditions not met, otherwise the position of the first zero.</p>\n"},"tw_bitmap_find_first_bit":{"type":"function","file":"bitmap/bitmap.h","line":210,"lineto":210,"args":[{"name":"bitmap","type":"const struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *bitmap","sig":"const struct tw_bitmap *","return":{"type":"int64_t","comment":null},"group":null,"description":"<p>tw_bitmap_find_first_bit() - find the first bit</p>\n\n<p>: bitmap to find first bit</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: -1 if not found or pre-conditions are not met, otherwise position of the first bit.</p>\n"},"tw_bitmap_not":{"type":"function","file":"bitmap/bitmap.h","line":220,"lineto":220,"args":[{"name":"bitmap","type":"struct tw_bitmap *","comment":null}],"argline":"struct tw_bitmap *bitmap","sig":"struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_not() - inverse all bits and zeroes in the bitmap</p>\n\n<p>: bitmap to inverse</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, pointer to bitmap otherwise.</p>\n"},"tw_bitmap_union":{"type":"function","file":"bitmap/bitmap.h","line":243,"lineto":244,"args":[{"name":"src","type":"const struct tw_bitmap *","comment":null},{"name":"dst","type":"struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *src, struct tw_bitmap *dst","sig":"const struct tw_bitmap *::struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_union() - compute the union of src and dst into dst</p>\n\n<p>: source bitmap to union</p>\n","comments":""},"tw_bitmap_intersection":{"type":"function","file":"bitmap/bitmap.h","line":255,"lineto":256,"args":[{"name":"src","type":"const struct tw_bitmap *","comment":null},{"name":"dst","type":"struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *src, struct tw_bitmap *dst","sig":"const struct tw_bitmap *::struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_intersection() - compute the intersection of src and dst into dst</p>\n\n<p>: source bitmap to intersect</p>\n","comments":""},"tw_bitmap_xor":{"type":"function","file":"bitmap/bitmap.h","line":267,"lineto":268,"args":[{"name":"src","type":"const struct tw_bitmap *","comment":null},{"name":"dst","type":"struct tw_bitmap *","comment":null}],"argline":"const struct tw_bitmap *src, struct tw_bitmap *dst","sig":"const struct tw_bitmap *::struct tw_bitmap *","return":{"type":"struct tw_bitmap *","comment":null},"group":null,"description":"<p>tw_bitmap_xor() - compute the symetric difference of src and dst into dst</p>\n\n<p>: source bitmap to xor</p>\n","comments":""},"tw_bitmap_rle_new":{"type":"function","file":"bitmap/bitmap_rle.h","line":47,"lineto":47,"args":[{"name":"nbits","type":"uint64_t","comment":null}],"argline":"uint64_t nbits","sig":"uint64_t","return":{"type":"struct tw_bitmap_rle *","comment":null},"group":null,"description":"<p>tw_bitmap_rle_new() - allocates a bitmap</p>\n\n<p>: number of bits the bitmap should hold</p>\n","comments":"<p>Bitmaps are static and do not grow in size. Bitmaps cannot contain more than TW_BITMAP_MAX_BITS.</p>\n\n<p>Return: NULL if allocation failed, otherwise a pointer to the newly         allocated <code>struct tw_bitmap_rle</code>.</p>\n"},"tw_bitmap_rle_free":{"type":"function","file":"bitmap/bitmap_rle.h","line":53,"lineto":53,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":null}],"argline":"struct tw_bitmap_rle *bitmap","sig":"struct tw_bitmap_rle *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bitmap_rle_free() - free a bitmap</p>\n\n<p>: bitmap to free</p>\n","comments":""},"tw_bitmap_rle_copy":{"type":"function","file":"bitmap/bitmap_rle.h","line":64,"lineto":65,"args":[{"name":"src","type":"const struct tw_bitmap_rle *","comment":null},{"name":"dst","type":"struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *src, struct tw_bitmap_rle *dst","sig":"const struct tw_bitmap_rle *::struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":null},"group":null,"description":"<p>tw_bitmap_rle_copy() - copy src bitmap into dst</p>\n\n<p>: bitmap to copy from</p>\n","comments":""},"tw_bitmap_rle_clone":{"type":"function","file":"bitmap/bitmap_rle.h","line":77,"lineto":77,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":null},"group":null,"description":"<p>tw_bitmap_rle_clone() - clone a bitmap into a new allocated bitmap</p>\n\n<p>: bitmap to clone</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise a newly allocated bitmap initialized from the requests bitmap. The caller is responsible to deallocated the bitmap with tw_bitmap_rle_free.</p>\n"},"tw_bitmap_rle_set":{"type":"function","file":"bitmap/bitmap_rle.h","line":88,"lineto":88,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":null},{"name":"pos","type":"uint64_t","comment":null}],"argline":"struct tw_bitmap_rle *bitmap, uint64_t pos","sig":"struct tw_bitmap_rle *::uint64_t","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bitmap_rle_set() - set position in bitmap</p>\n\n<p>: bitmap affected</p>\n","comments":"<p><code>bitmap&#39; must be non-null and</code>pos&#39; must be smaller than <code>bitmap.size&#39;. This function must always be called with a monotone increasing</code>pos&#39; argument.</p>\n"},"tw_bitmap_rle_set_word":{"type":"function","file":"bitmap/bitmap_rle.h","line":101,"lineto":102,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":null},{"name":"word","type":"const struct tw_bitmap_rle_word *","comment":null}],"argline":"struct tw_bitmap_rle *bitmap, const struct tw_bitmap_rle_word *word","sig":"struct tw_bitmap_rle *::const struct tw_bitmap_rle_word *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bitmap_rle_set_word() - set bitmap_rle_word in bitmap</p>\n\n<p>: bitmap affected</p>\n\n<p>:   range of bits in the form (start_pos, count) to set in the bitmap</p>\n","comments":"<p><code>bitmap&#39; must be non-null and</code>word.pos&#39; must be smaller than <code>bitmap.size&#39;, and</code>word.pos&#39; + `word.count&#39; must be smaller than TW_BITMAP_MAX_BITS. This is a helper internal-ish function to add ranges in one go instead of sequentially calling tw_bitmap_rle_set.</p>\n"},"tw_bitmap_rle_set_range":{"type":"function","file":"bitmap/bitmap_rle.h","line":114,"lineto":115,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":null},{"name":"start","type":"uint64_t","comment":null},{"name":"end","type":"uint64_t","comment":null}],"argline":"struct tw_bitmap_rle *bitmap, uint64_t start, uint64_t end","sig":"struct tw_bitmap_rle *::uint64_t::uint64_t","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bitmap_rle_set_range() - set range in bitmap</p>\n\n<p>: bitmap affected</p>\n\n<p>:   range of bits in the form (start_pos, end_pos) to set in the bitmap</p>\n","comments":"<p><code>bitmap&#39; must be non-null and</code>start&#39; must be smaller than the last set bit and (`word.pos + word.count&#39;) must be smaller than TW_BITMAP_MAX_BITS. This is a helper internal-ish function to add ranges in one go instead of sequentially calling tw_bitmap_rle_set.</p>\n"},"tw_bitmap_rle_count":{"type":"function","file":"bitmap/bitmap_rle.h","line":158,"lineto":158,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"uint64_t","comment":null},"group":null,"description":"<p>tw_bitmap_rle_count() - count the number of active bits</p>\n\n<p>: bitmap to count</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: 0 if pre-conditions are not met, otherwise number of active bits</p>\n"},"tw_bitmap_rle_density":{"type":"function","file":"bitmap/bitmap_rle.h","line":169,"lineto":169,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"float","comment":null},"group":null,"description":"<p>tw_bitmap_rle_density() - count the percentage of active bits</p>\n\n<p>: bitmap to count the density</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: 0.0 if pre-conditions are not met, otherwise the portion of active bits (count / size)</p>\n"},"tw_bitmap_rle_zero":{"type":"function","file":"bitmap/bitmap_rle.h","line":180,"lineto":180,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":null}],"argline":"struct tw_bitmap_rle *bitmap","sig":"struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":null},"group":null,"description":"<p>tw_bitmap_rle_zero() - clear all bits in a bitmap</p>\n\n<p>: bitmap to empty</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: NULL if pre-conditions are not met, otherswise the bitmap with zeroed bits.</p>\n"},"tw_bitmap_rle_fill":{"type":"function","file":"bitmap/bitmap_rle.h","line":191,"lineto":191,"args":[{"name":"bitmap","type":"struct tw_bitmap_rle *","comment":null}],"argline":"struct tw_bitmap_rle *bitmap","sig":"struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":null},"group":null,"description":"<p>tw_bitmap_rle_fill() - set all bits in a bitmap</p>\n\n<p>: bitmap to fill</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: NULL if pre-conditions are not met, otherswise the bitmap filled with bits.</p>\n"},"tw_bitmap_rle_find_first_zero":{"type":"function","file":"bitmap/bitmap_rle.h","line":202,"lineto":202,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"int64_t","comment":null},"group":null,"description":"<p>tw_bitmap_rle_find_first_zero() - find the first zero</p>\n\n<p>: bitmap to find first zero</p>\n","comments":"<p>`bitmap&#39; must be non-null.</p>\n\n<p>Return: -1 if not found or pre-conditions not met, otherwise the position of the first zero.</p>\n"},"tw_bitmap_rle_find_first_bit":{"type":"function","file":"bitmap/bitmap_rle.h","line":211,"lineto":211,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *bitmap","sig":"const struct tw_bitmap_rle *","return":{"type":"int64_t","comment":null},"group":null,"description":"<p>tw_bitmap_rle_find_first_bit() - find the first bit</p>\n\n<p>: bitmap to find first bit</p>\n","comments":"<p>Return: -1 if not found or pre-conditions not met, otherwise the position of the first bit.</p>\n"},"tw_bitmap_rle_not":{"type":"function","file":"bitmap/bitmap_rle.h","line":224,"lineto":225,"args":[{"name":"bitmap","type":"const struct tw_bitmap_rle *","comment":null},{"name":"dst","type":"struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *bitmap, struct tw_bitmap_rle *dst","sig":"const struct tw_bitmap_rle *::struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":null},"group":null,"description":"<p>tw_bitmap_rle_not() - inverse all bits and zeroes in the bitmap</p>\n\n<p>: bitmap to inverse</p>\n","comments":""},"tw_bitmap_rle_union":{"type":"function","file":"bitmap/bitmap_rle.h","line":250,"lineto":252,"args":[{"name":"a","type":"const struct tw_bitmap_rle *","comment":null},{"name":"b","type":"const struct tw_bitmap_rle *","comment":null},{"name":"dst","type":"struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *a, const struct tw_bitmap_rle *b, struct tw_bitmap_rle *dst","sig":"const struct tw_bitmap_rle *::const struct tw_bitmap_rle *::struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":null},"group":null,"description":"<p>tw_bitmap_rle_union() - union 2 bitmaps into a third</p>\n\n<p>:\n   first bitmap to union</p>\n\n<p>:\n   second bitmap to union</p>\n","comments":""},"tw_bitmap_rle_intersection":{"type":"function","file":"bitmap/bitmap_rle.h","line":264,"lineto":266,"args":[{"name":"a","type":"const struct tw_bitmap_rle *","comment":null},{"name":"b","type":"const struct tw_bitmap_rle *","comment":null},{"name":"dst","type":"struct tw_bitmap_rle *","comment":null}],"argline":"const struct tw_bitmap_rle *a, const struct tw_bitmap_rle *b, struct tw_bitmap_rle *dst","sig":"const struct tw_bitmap_rle *::const struct tw_bitmap_rle *::struct tw_bitmap_rle *","return":{"type":"struct tw_bitmap_rle *","comment":null},"group":null,"description":"<p>tw_bitmap_rle_intersection() - intersect 2 bitmaps into a third</p>\n\n<p>:\n   first bitmap to intersect</p>\n\n<p>:\n   second bitmap to intersect</p>\n","comments":""},"tw_bloomfilter_new":{"type":"function","file":"bloomfilter/bloomfilter.h","line":39,"lineto":39,"args":[{"name":"size","type":"uint64_t","comment":null},{"name":"k","type":"uint16_t","comment":null}],"argline":"uint64_t size, uint16_t k","sig":"uint64_t::uint16_t","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_new() - allocates a bloomfilter</p>\n\n<p>: number of bits the bloomfilter should hold</p>\n\n<p>:    number of hash functions used</p>\n","comments":"<p><code>k&#39; must be greater than 0,</code>size&#39; must be within (0, TW_BITMAP_MAX_BITS].</p>\n\n<p>Return: NULL if allocation failed, otherwise a pointer to the newly         allocated <code>struct tw_bloomfilter</code>.</p>\n"},"tw_bloomfilter_free":{"type":"function","file":"bloomfilter/bloomfilter.h","line":45,"lineto":45,"args":[{"name":"bf","type":"struct tw_bloomfilter *","comment":null}],"argline":"struct tw_bloomfilter *bf","sig":"struct tw_bloomfilter *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bloomfilter_free() - free a bloomfilter</p>\n\n<p>:\n bloomfilter to free</p>\n","comments":""},"tw_bloomfilter_copy":{"type":"function","file":"bloomfilter/bloomfilter.h","line":56,"lineto":57,"args":[{"name":"src","type":"const struct tw_bloomfilter *","comment":null},{"name":"dst","type":"struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *src, struct tw_bloomfilter *dst","sig":"const struct tw_bloomfilter *::struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_copy() - copy src bloomfilter into dst</p>\n\n<p>: bloomfilter to copy from</p>\n","comments":""},"tw_bloomfilter_clone":{"type":"function","file":"bloomfilter/bloomfilter.h","line":69,"lineto":69,"args":[{"name":"bf","type":"const struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *bf","sig":"const struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_clone() - clone a bloomfilter into a newly allocated one</p>\n\n<p>:\n bloomfilter to clone</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise a newly allocated bloomfilter initialized from the requested bloomfilter. The caller is responsible to deallocate with tw_bloomfilter_free.</p>\n"},"tw_bloomfilter_count":{"type":"function","file":"bloomfilter/bloomfilter.h","line":125,"lineto":125,"args":[{"name":"bf","type":"const struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *bf","sig":"const struct tw_bloomfilter *","return":{"type":"uint64_t","comment":null},"group":null,"description":"<p>tw_bloomfilter_count() - count the number of active bits</p>\n\n<p>:\n bloomfilter to count</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: number of active bits</p>\n"},"tw_bloomfilter_density":{"type":"function","file":"bloomfilter/bloomfilter.h","line":135,"lineto":135,"args":[{"name":"bf","type":"const struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *bf","sig":"const struct tw_bloomfilter *","return":{"type":"float","comment":null},"group":null,"description":"<p>tw_bloomfilter_density() - count the percentage of active bits</p>\n\n<p>:\n bloomfilter to count the density</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the portion of active bits (count / size)</p>\n"},"tw_bloomfilter_zero":{"type":"function","file":"bloomfilter/bloomfilter.h","line":145,"lineto":145,"args":[{"name":"bf","type":"struct tw_bloomfilter *","comment":null}],"argline":"struct tw_bloomfilter *bf","sig":"struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_zero() - clear all bits in a bloomfilter</p>\n\n<p>:\n bloomfilter to empty</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the bloomfilter cleared</p>\n"},"tw_bloomfilter_fill":{"type":"function","file":"bloomfilter/bloomfilter.h","line":155,"lineto":155,"args":[{"name":"bf","type":"struct tw_bloomfilter *","comment":null}],"argline":"struct tw_bloomfilter *bf","sig":"struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_fill() - set all bits in a bloomfilter</p>\n\n<p>:\n bloomfilter to fill</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the bloomfilter filled</p>\n"},"tw_bloomfilter_not":{"type":"function","file":"bloomfilter/bloomfilter.h","line":165,"lineto":165,"args":[{"name":"bf","type":"struct tw_bloomfilter *","comment":null}],"argline":"struct tw_bloomfilter *bf","sig":"struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_not() - inverse all bits and zeroes in the bloomfilter</p>\n\n<p>:\n bloomfilter to inverse</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise the bloomfilter.</p>\n"},"tw_bloomfilter_union":{"type":"function","file":"bloomfilter/bloomfilter.h","line":194,"lineto":195,"args":[{"name":"src","type":"const struct tw_bloomfilter *","comment":null},{"name":"dst","type":"struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *src, struct tw_bloomfilter *dst","sig":"const struct tw_bloomfilter *::struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_union() - computer the union of bloomfilters</p>\n\n<p>: source bloomfilter to union</p>\n","comments":""},"tw_bloomfilter_intersection":{"type":"function","file":"bloomfilter/bloomfilter.h","line":209,"lineto":211,"args":[{"name":"src","type":"const struct tw_bloomfilter *","comment":null},{"name":"dst","type":"struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *src, struct tw_bloomfilter *dst","sig":"const struct tw_bloomfilter *::struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_intersection() - compute the intersection of bloomfilters</p>\n\n<p>: source bloomfilter to intersection</p>\n","comments":""},"tw_bloomfilter_xor":{"type":"function","file":"bloomfilter/bloomfilter.h","line":225,"lineto":226,"args":[{"name":"src","type":"const struct tw_bloomfilter *","comment":null},{"name":"dst","type":"struct tw_bloomfilter *","comment":null}],"argline":"const struct tw_bloomfilter *src, struct tw_bloomfilter *dst","sig":"const struct tw_bloomfilter *::struct tw_bloomfilter *","return":{"type":"struct tw_bloomfilter *","comment":null},"group":null,"description":"<p>tw_bloomfilter_xor() - compute the symetric difference of bloomfilters</p>\n\n<p>: source bloomfilter to xor</p>\n","comments":""},"tw_bloomfilter_a2_new":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":41,"lineto":42,"args":[{"name":"size","type":"uint64_t","comment":null},{"name":"k","type":"uint16_t","comment":null},{"name":"dentisy","type":"float","comment":null}],"argline":"uint64_t size, uint16_t k, float dentisy","sig":"uint64_t::uint16_t::float","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_new() - allocates a bloomfilter</p>\n\n<p>:    number of bits the bloomfilter should hold</p>\n\n<p>:       number of hash functions used</p>\n\n<p>: threshold for rotation</p>\n","comments":"<p><code>size&#39; must be within (0, TW_BITMAP_MAX_BITS],</code>k&#39; must be within (0, UINT16_MAX] and `density&#39; within (0, 1].</p>\n\n<p>Return: NULL if allocation failed, otherwise a pointer to the newly         allocated <code>struct tw_bloomfilter_a2</code>.</p>\n"},"tw_bloomfilter_a2_free":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":48,"lineto":48,"args":[{"name":"bf","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"struct tw_bloomfilter_a2 *bf","sig":"struct tw_bloomfilter_a2 *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_free() - free a bloomfilter</p>\n\n<p>:\n bloomfilter to free</p>\n","comments":""},"tw_bloomfilter_a2_copy":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":61,"lineto":63,"args":[{"name":"src","type":"const struct tw_bloomfilter_a2 *","comment":null},{"name":"dst","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *src, struct tw_bloomfilter_a2 *dst","sig":"const struct tw_bloomfilter_a2 *::struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_copy() - copy src bloomfilter into dst</p>\n\n<p>: bloomfilter to copy from</p>\n","comments":""},"tw_bloomfilter_a2_clone":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":75,"lineto":76,"args":[{"name":"bf","type":"const struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *bf","sig":"const struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_clone() - clone a bloomfilter into a newly allocated one</p>\n\n<p>:\n bloomfilter to clone</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise a newly allocated bloomfilter initialized from the requested bloomfilter. The caller is responsible to deallocate with tw_bloomfilter_a2_free.</p>\n"},"tw_bloomfilter_a2_count":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":128,"lineto":128,"args":[{"name":"bf","type":"const struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *bf","sig":"const struct tw_bloomfilter_a2 *","return":{"type":"uint64_t","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_count() - count the number of active bits</p>\n\n<p>:\n bloomfilter to count</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: number of active bits in both bloomfilters</p>\n"},"tw_bloomfilter_a2_density":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":138,"lineto":138,"args":[{"name":"bf","type":"const struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *bf","sig":"const struct tw_bloomfilter_a2 *","return":{"type":"float","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_density() - count the percentage of active bits</p>\n\n<p>:\n bloomfilter to count the density</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the portion of active bits (count / size)</p>\n"},"tw_bloomfilter_a2_zero":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":148,"lineto":148,"args":[{"name":"bf","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"struct tw_bloomfilter_a2 *bf","sig":"struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_zero() - clear all bits in a bloomfilter</p>\n\n<p>:\n bloomfilter to empty</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the bloomfilter cleared</p>\n"},"tw_bloomfilter_a2_fill":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":158,"lineto":158,"args":[{"name":"bf","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"struct tw_bloomfilter_a2 *bf","sig":"struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_fill() - set all bits in a bloomfilter</p>\n\n<p>:\n bloomfilter to fill</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: the bloomfilter filled</p>\n"},"tw_bloomfilter_a2_not":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":168,"lineto":168,"args":[{"name":"bf","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"struct tw_bloomfilter_a2 *bf","sig":"struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_not() - inverse all bits and zeroes in the bloomfilter</p>\n\n<p>:\n bloomfilter to inverse</p>\n","comments":"<p>`bf&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise the bloomfilter.</p>\n"},"tw_bloomfilter_a2_union":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":197,"lineto":199,"args":[{"name":"src","type":"const struct tw_bloomfilter_a2 *","comment":null},{"name":"dst","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *src, struct tw_bloomfilter_a2 *dst","sig":"const struct tw_bloomfilter_a2 *::struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_union() - computer the union of bloomfilters</p>\n\n<p>: source bloomfilter to union</p>\n","comments":""},"tw_bloomfilter_a2_intersection":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":213,"lineto":215,"args":[{"name":"src","type":"const struct tw_bloomfilter_a2 *","comment":null},{"name":"dst","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *src, struct tw_bloomfilter_a2 *dst","sig":"const struct tw_bloomfilter_a2 *::struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_intersection() - compute the intersection of bloomfilters</p>\n\n<p>: source bloomfilter to intersection</p>\n","comments":""},"tw_bloomfilter_a2_xor":{"type":"function","file":"bloomfilter/bloomfilter_a2.h","line":229,"lineto":231,"args":[{"name":"src","type":"const struct tw_bloomfilter_a2 *","comment":null},{"name":"dst","type":"struct tw_bloomfilter_a2 *","comment":null}],"argline":"const struct tw_bloomfilter_a2 *src, struct tw_bloomfilter_a2 *dst","sig":"const struct tw_bloomfilter_a2 *::struct tw_bloomfilter_a2 *","return":{"type":"struct tw_bloomfilter_a2 *","comment":null},"group":null,"description":"<p>tw_bloomfilter_a2_xor() - compute the symetric difference of bloomfilters</p>\n\n<p>: source bloomfilter to xor</p>\n","comments":""},"tw_minhash_new":{"type":"function","file":"hash/minhash.h","line":29,"lineto":29,"args":[{"name":"n_registers","type":"uint32_t","comment":null}],"argline":"uint32_t n_registers","sig":"uint32_t","return":{"type":"struct tw_minhash *","comment":null},"group":null,"description":"<p>tw_minhash_new() - allocates a minhash structure</p>\n\n<p>_registers: number of 64bit registers the structure holds</p>\n","comments":"<p>`n_registers&#39; must be greater than 0.</p>\n\n<p>Return: NULL if allocation failed, otherwise a pointer to the newly allocated <code>struct tw_minhash</code>.</p>\n\n<p>Note: The allocation will be rounded up to the closest multiple of a cacheline.</p>\n"},"tw_minhash_free":{"type":"function","file":"hash/minhash.h","line":35,"lineto":35,"args":[{"name":"hash","type":"struct tw_minhash *","comment":null}],"argline":"struct tw_minhash *hash","sig":"struct tw_minhash *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_mihash_free() - free a minhash</p>\n\n<p>: hash to free</p>\n","comments":""},"tw_minhash_copy":{"type":"function","file":"hash/minhash.h","line":47,"lineto":48,"args":[{"name":"src","type":"const struct tw_minhash *","comment":null},{"name":"dst","type":"struct tw_minhash *","comment":null}],"argline":"const struct tw_minhash *src, struct tw_minhash *dst","sig":"const struct tw_minhash *::struct tw_minhash *","return":{"type":"struct tw_minhash *","comment":null},"group":null,"description":"<p>tw_mihash_copy() - copy <code>src</code> minhash into <code>dst</code></p>\n\n<p>: minhash to copy from</p>\n","comments":""},"tw_minhash_clone":{"type":"function","file":"hash/minhash.h","line":60,"lineto":60,"args":[{"name":"hash","type":"const struct tw_minhash *","comment":null}],"argline":"const struct tw_minhash *hash","sig":"const struct tw_minhash *","return":{"type":"struct tw_minhash *","comment":null},"group":null,"description":"<p>tw_minhash_clone() - clone a minash into a new allocated minhash</p>\n\n<p>: minhash to clone</p>\n","comments":"<p>`hash&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise a newly allocated minhash initialized from the requests minhash. The caller is responsible to deallocated the minhash with tw_minhash_free.</p>\n"},"tw_minhash_estimate":{"type":"function","file":"hash/minhash.h","line":82,"lineto":83,"args":[{"name":"fst","type":"const struct tw_minhash *","comment":null},{"name":"snd","type":"const struct tw_minhash *","comment":null}],"argline":"const struct tw_minhash *fst, const struct tw_minhash *snd","sig":"const struct tw_minhash *::const struct tw_minhash *","return":{"type":"float","comment":null},"group":null,"description":"<p>tw_minhash_estimate() - estimate the jaccard index between two minhash.</p>\n\n<p>: first minhash</p>\n\n<p>: second minhash</p>\n","comments":"<p><code>fst&#39; and</code>snd&#39; must be non-null and of equal size.</p>\n\n<p>Return: 0.0 if pre-conditions are not met, otherwise the estimated jaccard index of <code>fst</code> and <code>snd</code>.</p>\n"},"tw_minhash_merge":{"type":"function","file":"hash/minhash.h","line":108,"lineto":109,"args":[{"name":"src","type":"const struct tw_minhash *","comment":null},{"name":"dst","type":"struct tw_minhash *","comment":null}],"argline":"const struct tw_minhash *src, struct tw_minhash *dst","sig":"const struct tw_minhash *::struct tw_minhash *","return":{"type":"struct tw_minhash *","comment":null},"group":null,"description":"<p>tw_minhash_merge() - merge src into dst</p>\n\n<p>: minhash to merge from</p>\n","comments":""},"tw_hyperloglog_new":{"type":"function","file":"hyperloglog/hyperloglog.h","line":41,"lineto":41,"args":[{"name":"precision","type":"uint8_t","comment":null}],"argline":"uint8_t precision","sig":"uint8_t","return":{"type":"struct tw_hyperloglog *","comment":null},"group":null,"description":"<p>tw_hyperloglog_new() - allocates a hyperloglog data structure</p>\n\n<p>: precision hyperloglog should use</p>\n","comments":"<p>`precision&#39; must be within [TW_HLL_MIN_PRECISION, TW_HLL_MAX_PRECISION].</p>\n\n<p>Return: NULL if allocation failed, otherwise a pointer to the newly         allocated <code>struct tw_hyperloglog</code>.</p>\n"},"tw_hyperloglog_free":{"type":"function","file":"hyperloglog/hyperloglog.h","line":47,"lineto":47,"args":[{"name":"hll","type":"struct tw_hyperloglog *","comment":null}],"argline":"struct tw_hyperloglog *hll","sig":"struct tw_hyperloglog *","return":{"type":"void","comment":null},"group":null,"description":"<p>tw_hyperloglog_free() - free a hyperloglog</p>\n\n<p>: hyperloglog to free</p>\n","comments":""},"tw_hyperloglog_copy":{"type":"function","file":"hyperloglog/hyperloglog.h","line":58,"lineto":59,"args":[{"name":"src","type":"const struct tw_hyperloglog *","comment":null},{"name":"dst","type":"struct tw_hyperloglog *","comment":null}],"argline":"const struct tw_hyperloglog *src, struct tw_hyperloglog *dst","sig":"const struct tw_hyperloglog *::struct tw_hyperloglog *","return":{"type":"struct tw_hyperloglog *","comment":null},"group":null,"description":"<p>tw_hyperloglog_copy() - copy src hyperloglog into dst</p>\n\n<p>: hyperloglog to copy from</p>\n","comments":""},"tw_hyperloglog_clone":{"type":"function","file":"hyperloglog/hyperloglog.h","line":71,"lineto":71,"args":[{"name":"hll","type":"const struct tw_hyperloglog *","comment":null}],"argline":"const struct tw_hyperloglog *hll","sig":"const struct tw_hyperloglog *","return":{"type":"struct tw_hyperloglog *","comment":null},"group":null,"description":"<p>tw_hyperloglog_clone() - clone a hyperloglog into a newly allocated one</p>\n\n<p>: hyperloglog to clone</p>\n","comments":"<p>`hll&#39; must be non-null.</p>\n\n<p>Return: NULL if failed, otherwise a newly allocated hyperloglog initialized from the requested hyperloglog. The caller is responsible to deallocate with tw_hyperloglog_free.</p>\n"},"tw_hyperloglog_count":{"type":"function","file":"hyperloglog/hyperloglog.h","line":92,"lineto":92,"args":[{"name":"hll","type":"const struct tw_hyperloglog *","comment":null}],"argline":"const struct tw_hyperloglog *hll","sig":"const struct tw_hyperloglog *","return":{"type":"double","comment":null},"group":null,"description":"<p>tw_hyperloglog_count() - estimate the number of elements in hll</p>\n\n<p>: hyperloglog to estimate</p>\n","comments":"<p>`hll&#39; must be non-null.</p>\n\n<p>Return: 0.0 if hll is NULL, otherwise theestimated number of elements in hll.</p>\n"},"tw_hyperloglog_merge":{"type":"function","file":"hyperloglog/hyperloglog.h","line":117,"lineto":118,"args":[{"name":"src","type":"const struct tw_hyperloglog *","comment":null},{"name":"dst","type":"struct tw_hyperloglog *","comment":null}],"argline":"const struct tw_hyperloglog *src, struct tw_hyperloglog *dst","sig":"const struct tw_hyperloglog *::struct tw_hyperloglog *","return":{"type":"struct tw_hyperloglog *","comment":null},"group":null,"description":"<p>tw_hyperloglog_merge() - merge src into dst</p>\n\n<p>: hyperloglog to merge from</p>\n","comments":""}},"callbacks":{},"globals":{},"types":[["tw_bitmap",{"decl":["uint64_t size","uint64_t count","uint64_t * data"],"type":"struct","value":"tw_bitmap","file":"bitmap/bitmap.h","line":23,"lineto":27,"block":"uint64_t size\nuint64_t count\nuint64_t * data","tdef":null,"description":" struct tw_bitmap - bitmap data structure\n \n\n:  storage capacity in bits\n \n\n: number of active bits\n ","comments":"<p>This is the most basic implementation of a bitmap. It does not support resizing and concurrent operations (unless constrained to reads only).</p>\n\n<p>There&#39;s a small overhead when setting/clearing bit to maintain the number of active bits. This comes with a O(1) tw_bitmap_count and derived operations.</p>\n","fields":[{"type":"uint64_t","name":"size","comments":""},{"type":"uint64_t","name":"count","comments":""},{"type":"uint64_t *","name":"data","comments":""}],"used":{"returns":["tw_bitmap_clone","tw_bitmap_copy","tw_bitmap_fill","tw_bitmap_intersection","tw_bitmap_new","tw_bitmap_not","tw_bitmap_rle_clone","tw_bitmap_rle_copy","tw_bitmap_rle_fill","tw_bitmap_rle_intersection","tw_bitmap_rle_new","tw_bitmap_rle_not","tw_bitmap_rle_union","tw_bitmap_rle_zero","tw_bitmap_union","tw_bitmap_xor","tw_bitmap_zero"],"needs":["tw_bitmap_clear","tw_bitmap_clone","tw_bitmap_copy","tw_bitmap_count","tw_bitmap_density","tw_bitmap_fill","tw_bitmap_find_first_bit","tw_bitmap_find_first_zero","tw_bitmap_free","tw_bitmap_intersection","tw_bitmap_not","tw_bitmap_rle_clone","tw_bitmap_rle_copy","tw_bitmap_rle_count","tw_bitmap_rle_density","tw_bitmap_rle_fill","tw_bitmap_rle_find_first_bit","tw_bitmap_rle_find_first_zero","tw_bitmap_rle_free","tw_bitmap_rle_intersection","tw_bitmap_rle_not","tw_bitmap_rle_set","tw_bitmap_rle_set_range","tw_bitmap_rle_set_word","tw_bitmap_rle_union","tw_bitmap_rle_zero","tw_bitmap_set","tw_bitmap_union","tw_bitmap_xor","tw_bitmap_zero"]}}],["tw_bitmap_rle",{"decl":["uint64_t size","uint64_t count","uint64_t last_pos","uint64_t last_word_idx","uint64_t alloc_word","struct tw_bitmap_rle_word * data"],"type":"struct","value":"tw_bitmap_rle","file":"bitmap/bitmap_rle.h","line":26,"lineto":35,"block":"uint64_t size\nuint64_t count\nuint64_t last_pos\nuint64_t last_word_idx\nuint64_t alloc_word\nstruct tw_bitmap_rle_word * data","tdef":null,"description":" struct tw_bitmap_rle - rle-bitmap data structure\n \n\n:          bitmap info header\n \n\n_pos:      position of the last set bit\n \n\n_word_idx: index of the current bitmap_t in ","comments":"","fields":[{"type":"uint64_t","name":"size","comments":""},{"type":"uint64_t","name":"count","comments":""},{"type":"uint64_t","name":"last_pos","comments":""},{"type":"uint64_t","name":"last_word_idx","comments":""},{"type":"uint64_t","name":"alloc_word","comments":""},{"type":"struct tw_bitmap_rle_word *","name":"data","comments":""}],"used":{"returns":["tw_bitmap_rle_clone","tw_bitmap_rle_copy","tw_bitmap_rle_fill","tw_bitmap_rle_intersection","tw_bitmap_rle_new","tw_bitmap_rle_not","tw_bitmap_rle_union","tw_bitmap_rle_zero"],"needs":["tw_bitmap_rle_clone","tw_bitmap_rle_copy","tw_bitmap_rle_count","tw_bitmap_rle_density","tw_bitmap_rle_fill","tw_bitmap_rle_find_first_bit","tw_bitmap_rle_find_first_zero","tw_bitmap_rle_free","tw_bitmap_rle_intersection","tw_bitmap_rle_not","tw_bitmap_rle_set","tw_bitmap_rle_set_range","tw_bitmap_rle_set_word","tw_bitmap_rle_union","tw_bitmap_rle_zero"]}}],["tw_bitmap_rle_word",{"decl":["uint64_t pos","uint64_t count"],"type":"struct","value":"tw_bitmap_rle_word","file":"bitmap/bitmap_rle.h","line":13,"lineto":16,"block":"uint64_t pos\nuint64_t count","tdef":null,"description":" Run Length Encoding (RLE) bitmaps are compressed bitmaps. Depending on the\n density of actives bits, it can compress considerably. This implementation\n is semi mutable as you can only add increasing positions.","comments":"","fields":[{"type":"uint64_t","name":"pos","comments":""},{"type":"uint64_t","name":"count","comments":""}],"used":{"returns":[],"needs":["tw_bitmap_rle_set_word"]}}],["tw_bloomfilter",{"decl":["uint16_t k","struct tw_bitmap * bitmap"],"type":"struct","value":"tw_bloomfilter","file":"bloomfilter/bloomfilter.h","line":24,"lineto":27,"block":"uint16_t k\nstruct tw_bitmap * bitmap","tdef":null,"description":" struct tw_bloomfilter - bloomfilter\n \n\n:      number of hash functions\n \n\n: bitmap holding the bits","comments":"<p>This bloomfilter is static and does not support automatic resizing. The underlaying storage is struct tw_bitmap.</p>\n","fields":[{"type":"uint16_t","name":"k","comments":""},{"type":"struct tw_bitmap *","name":"bitmap","comments":""}],"used":{"returns":["tw_bloomfilter_a2_clone","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_new","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_xor","tw_bloomfilter_a2_zero","tw_bloomfilter_clone","tw_bloomfilter_copy","tw_bloomfilter_fill","tw_bloomfilter_intersection","tw_bloomfilter_new","tw_bloomfilter_not","tw_bloomfilter_union","tw_bloomfilter_xor","tw_bloomfilter_zero"],"needs":["tw_bloomfilter_a2_clone","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_count","tw_bloomfilter_a2_density","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_free","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_xor","tw_bloomfilter_a2_zero","tw_bloomfilter_clone","tw_bloomfilter_copy","tw_bloomfilter_count","tw_bloomfilter_density","tw_bloomfilter_fill","tw_bloomfilter_free","tw_bloomfilter_intersection","tw_bloomfilter_not","tw_bloomfilter_union","tw_bloomfilter_xor","tw_bloomfilter_zero"]}}],["tw_bloomfilter_a2",{"decl":["float density","struct tw_bloomfilter * active","struct tw_bloomfilter * passive"],"type":"struct","value":"tw_bloomfilter_a2","file":"bloomfilter/bloomfilter_a2.h","line":22,"lineto":27,"block":"float density\nstruct tw_bloomfilter * active\nstruct tw_bloomfilter * passive","tdef":null,"description":" struct tw_bloomfilter_a2 - aging bloom filter with active buffers\n \n\n: density threshold to trigger rotation\n \n\n:  pointer to active bloomfilter\n \n\n: pointer to passive bloomfilter","comments":"<p>The paper &quot;Aging bloom filter with two active buffers for dynamic sets&quot; describe a method where 2 bloom filters are used to implement a FIFO.</p>\n\n<p>Elements are added to <code>active</code> until <code>density</code> (on active). Once this happen, <code>passive</code> is cleared and both filters are swapped.</p>\n","fields":[{"type":"float","name":"density","comments":""},{"type":"struct tw_bloomfilter *","name":"active","comments":""},{"type":"struct tw_bloomfilter *","name":"passive","comments":""}],"used":{"returns":["tw_bloomfilter_a2_clone","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_new","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_xor","tw_bloomfilter_a2_zero"],"needs":["tw_bloomfilter_a2_clone","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_count","tw_bloomfilter_a2_density","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_free","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_xor","tw_bloomfilter_a2_zero"]}}],["tw_hyperloglog",{"decl":["uint8_t precision","uint8_t * registers"],"type":"struct","value":"tw_hyperloglog","file":"hyperloglog/hyperloglog.h","line":27,"lineto":30,"block":"uint8_t precision\nuint8_t * registers","tdef":null,"description":" struct tw_hyperloglog - hyperloglog data structure\n \n\n: number of registers will be defined as 2^precision.\n \n\n: allocated array containing the 8bit registers","comments":"<p>This implementation does not use the 6-bit packing and/or mix dense/sparse representation proposed in the [1].</p>\n\n<p>[1] Heule, Stefan, Marc Nunkesser, and Alexander Hall. &quot;HyperLogLog in practice: Algorithmic engineering of a state of the art cardinality estimation algorithm.&quot; Proceedings of the 16th International Conference on Extending Database Technology. ACM, 2013.</p>\n","fields":[{"type":"uint8_t","name":"precision","comments":""},{"type":"uint8_t *","name":"registers","comments":""}],"used":{"returns":["tw_hyperloglog_clone","tw_hyperloglog_copy","tw_hyperloglog_merge","tw_hyperloglog_new"],"needs":["tw_hyperloglog_clone","tw_hyperloglog_copy","tw_hyperloglog_count","tw_hyperloglog_free","tw_hyperloglog_merge"]}}],["tw_minhash",{"decl":["uint32_t n_registers","uint32_t * registers"],"type":"struct","value":"tw_minhash","file":"hash/minhash.h","line":12,"lineto":15,"block":"uint32_t n_registers\nuint32_t * registers","tdef":null,"description":" struct tw_minhash - minhash data structure\n \n\n_registers: number of registers\n \n\n: registers holding computed values","comments":"","fields":[{"type":"uint32_t","name":"n_registers","comments":""},{"type":"uint32_t *","name":"registers","comments":""}],"used":{"returns":["tw_minhash_clone","tw_minhash_copy","tw_minhash_merge","tw_minhash_new"],"needs":["tw_minhash_clone","tw_minhash_copy","tw_minhash_estimate","tw_minhash_free","tw_minhash_merge"]}}]],"prefix":"include/twiddle","groups":[["no_group",["tw_bitmap_new","tw_bitmap_free","tw_bitmap_copy","tw_bitmap_clone","tw_bitmap_set","tw_bitmap_clear","tw_bitmap_count","tw_bitmap_density","tw_bitmap_zero","tw_bitmap_fill","tw_bitmap_find_first_zero","tw_bitmap_find_first_bit","tw_bitmap_not","tw_bitmap_union","tw_bitmap_intersection","tw_bitmap_xor","tw_bitmap_rle_new","tw_bitmap_rle_free","tw_bitmap_rle_copy","tw_bitmap_rle_clone","tw_bitmap_rle_set","tw_bitmap_rle_set_word","tw_bitmap_rle_set_range","tw_bitmap_rle_count","tw_bitmap_rle_density","tw_bitmap_rle_zero","tw_bitmap_rle_fill","tw_bitmap_rle_find_first_zero","tw_bitmap_rle_find_first_bit","tw_bitmap_rle_not","tw_bitmap_rle_union","tw_bitmap_rle_intersection","tw_bloomfilter_new","tw_bloomfilter_free","tw_bloomfilter_copy","tw_bloomfilter_clone","tw_bloomfilter_count","tw_bloomfilter_density","tw_bloomfilter_zero","tw_bloomfilter_fill","tw_bloomfilter_not","tw_bloomfilter_union","tw_bloomfilter_intersection","tw_bloomfilter_xor","tw_bloomfilter_a2_new","tw_bloomfilter_a2_free","tw_bloomfilter_a2_copy","tw_bloomfilter_a2_clone","tw_bloomfilter_a2_count","tw_bloomfilter_a2_density","tw_bloomfilter_a2_zero","tw_bloomfilter_a2_fill","tw_bloomfilter_a2_not","tw_bloomfilter_a2_union","tw_bloomfilter_a2_intersection","tw_bloomfilter_a2_xor","tw_minhash_new","tw_minhash_free","tw_minhash_copy","tw_minhash_clone","tw_minhash_estimate","tw_minhash_merge","tw_hyperloglog_new","tw_hyperloglog_free","tw_hyperloglog_copy","tw_hyperloglog_clone","tw_hyperloglog_count","tw_hyperloglog_merge"]]],"examples":[["bf-uniq.c","ex/v1.0.0/bf-uniq.html"],["example-bitmap-rle.c","ex/v1.0.0/example-bitmap-rle.html"],["example-bitmap.c","ex/v1.0.0/example-bitmap.html"],["example-bloomfilter-a2.c","ex/v1.0.0/example-bloomfilter-a2.html"],["example-bloomfilter.c","ex/v1.0.0/example-bloomfilter.html"],["example-hyperloglog.c","ex/v1.0.0/example-hyperloglog.html"],["example-minhash.c","ex/v1.0.0/example-minhash.html"],["hll-wc.c","ex/v1.0.0/hll-wc.html"]]}